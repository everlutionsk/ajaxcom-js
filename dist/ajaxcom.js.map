{"version":3,"sources":["webpack://ajaxcom/webpack/universalModuleDefinition","webpack://ajaxcom/webpack/bootstrap","webpack://ajaxcom/./src/handler/request.ts","webpack://ajaxcom/./src/handler/fragmentOptions.ts","webpack://ajaxcom/./src/handler/scroll.ts","webpack://ajaxcom/./src/ajaxcom.ts","webpack://ajaxcom/./src/handler/click.ts","webpack://ajaxcom/./src/handler/operations.ts","webpack://ajaxcom/./src/operation/callback.ts","webpack://ajaxcom/./src/operation/changeUrl.ts","webpack://ajaxcom/./src/operation/container.ts","webpack://ajaxcom/./src/handler/submit.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","options","Promise","beforeSend","fetchOperations","response","ok","success","error","handleOperations","complete","fetchOptions","fragment","length","headers","substring","completeFunction","scrollToElement","hash","element","document","querySelector","substr","scrollIntoView","defaultCallbacks","resolve","alert","ajaxcomOptions","formsSelector","linksSelector","addEventListener","toHandleClick","toHandleSubmit","onpopstate","event","link","target","srcElement","location","href","replace","hasEmptyHash","state","reload","url","requestOptions","ajaxcomCallbacks","method","request","isNotAnchor","tagName","toUpperCase","isExternalLink","hostname","protocol","isNotAnchorOnSamePage","isAnchorEmpty","parentElement","getLink","matches","preventDefault","which","metaKey","ctrlKey","shiftKey","altKey","isNonAjaxcomCall","some","f","isInvalid","addFragmentOptions","fetch","body","cache","credentials","Headers","json","then","data","forEach","operation","handleContainer","handleChangeUrl","handleCallback","Error","handleOperation","namespaces","callFunction","split","context","item","undefined","params","handler","currentUrlHref","search","currentUrlPath","pathname","history","pushState","pushUrl","replaceState","replaceUrl","redirectToUrl","setTimeout","wait","getNodes","html","createRange","createContextualFragment","selection","querySelectorAll","nodes","elements","Array","from","innerHTML","remove","appendChild","insertBefore","firstChild","prepend","parentNode","nextSibling","insertAfter","outerHTML","classList","add","setAttribute","attr","form","formData","FormData","action","query","entries","map","pair","encodeURIComponent","join","glue","indexOf","fetchOptionsForGet","fetchOptionsForPost","hashPosition","getFetchOptions"],"mappings":"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","file":"ajaxcom.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ajaxcom\"] = factory();\n\telse\n\t\troot[\"ajaxcom\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","import {IAjaxcomCallbacks} from \"../options/callbacks\";\nimport {IFetchOptions} from \"../options/fetchOptions\";\nimport {fetchOperations, handleOperations} from \"./operations\";\n\nexport async function request(options: Partial<IAjaxcomCallbacks & IFetchOptions>): Promise<void> {\n    try {\n        await options.beforeSend();\n        const response = await fetchOperations(options);\n\n        if (!response.ok) {\n            options.error(response);\n            return;\n        }\n\n        await options.success();\n        await handleOperations(response);\n        options.complete();\n    } catch (e) {\n        options.error(e);\n    }\n}\n","import {IAjaxcomCallbacks} from \"../options/callbacks\";\nimport {IFetchOptions} from \"../options/fetchOptions\";\nimport {scrollToElement} from \"./scroll\";\n\ntype FetchOptions = Partial<IAjaxcomCallbacks & IFetchOptions>;\n\nexport function addFragmentOptions(fetchOptions: FetchOptions, fragment?: string): FetchOptions {\n    if (fragment.length === 0) { return fetchOptions; }\n\n    fetchOptions.headers = {\"X-AjaxComFragment\": fragment.substring(1)};\n\n    const completeFunction = fetchOptions.complete;\n    fetchOptions.complete = () => {\n        scrollToElement(fragment);\n        completeFunction();\n    };\n\n    return fetchOptions;\n}\n","export function scrollToElement(hash: string): void {\n    if (hash.length < 1) { return; }\n\n    let element = document.querySelector(hash);\n    if (null === element) { element = document.querySelector(`[name=${hash.substr(1)}]`); }\n    if (null === element) { return; }\n\n    element.scrollIntoView();\n}\n","import {IAjaxcomCallbacks} from \"options/callbacks\";\nimport {toHandleClick} from \"./handler/click\";\nimport {request} from \"./handler/request\";\nimport {toHandleSubmit} from \"./handler/submit\";\nimport {IFetchOptions} from \"./options/fetchOptions\";\nimport {IAjaxcomSelectors} from \"./options/selectors\";\n\nconst defaultCallbacks = {\n    beforeSend: () => Promise.resolve(),\n    complete: () => undefined,\n    error: onError,\n    success: () => Promise.resolve(),\n};\n\nexport function initialize(options: Partial<IAjaxcomSelectors & IAjaxcomCallbacks>) {\n    const ajaxcomOptions = {\n        ...defaultCallbacks,\n        formsSelector: \"form:not([data-ignore-ajaxcom])\",\n        linksSelector: \"a:not([target=_blank]):not([data-ignore-ajaxcom])\",\n        ...options,\n    };\n\n    document.addEventListener(\"click\", toHandleClick(ajaxcomOptions));\n    document.addEventListener(\"submit\", toHandleSubmit(ajaxcomOptions));\n\n    window.onpopstate = (event: PopStateEvent) => {\n        const link = (event.target || event.srcElement) as Window;\n\n        if (link.location.hash && hasEmptyHash(link)) {\n            return;\n        }\n\n        if (typeof event.state !== \"object\" || event.state === null) {\n            window.location.reload();\n        }\n        window.location.href = event.state.url;\n    };\n\n    function hasEmptyHash(link: Window) {\n        return link.location.href.replace(link.location.hash, \"\") === location.href.replace(location.hash, \"\");\n    }\n}\n\nexport async function fetch(requestOptions: IFetchOptions,\n                            ajaxcomCallbacks: Partial<IAjaxcomCallbacks>): Promise<void> {\n    const options = {\n        method: \"GET\",\n        ...defaultCallbacks,\n        ...ajaxcomCallbacks,\n        ...requestOptions,\n    } as Partial<IAjaxcomCallbacks & IFetchOptions>;\n\n    request(options);\n}\n\nfunction onError() {\n    alert(\"Server cannot handle your request. Please try it again or contact the administrator.\");\n}\n","import {IAjaxcomCallbacks} from \"../options/callbacks\";\nimport {IFetchOptions} from \"../options/fetchOptions\";\nimport {IAjaxcomSelectors} from \"../options/selectors\";\nimport {addFragmentOptions} from \"./fragmentOptions\";\nimport {request} from \"./request\";\nimport {scrollToElement} from \"./scroll\";\n\nexport function toHandleClick(options: Partial<IAjaxcomSelectors &IAjaxcomCallbacks>) {\n    return (event: MouseEvent) => {\n        const link = getLink(event);\n        if (link.matches(\"[href^='#']\")) {\n            event.preventDefault();\n            // Unlike Chrome, in Firefox, window.location.hash = ''; would result in actual appending of '#' to\n            // current URL, which will trigger window.popstate event. From inside our popstate handler we have no\n            // way to detect this and differentiate empty location hash from navigating to current URL (without hash).\n            if (link.hash) {\n                window.location.hash = link.hash;\n            }\n            scrollToElement(link.hash);\n            return;\n        }\n\n        if (!link.matches(options.linksSelector)) { return; }\n        if (isNonAjaxcomCall(event)) { return; }\n        if (isInvalid(link)) { return; }\n\n        event.preventDefault();\n        const fetchOptions = {\n            ...options,\n            method: \"GET\",\n            url: link.href,\n        } as Partial<IAjaxcomCallbacks & IFetchOptions>;\n\n        request(addFragmentOptions(fetchOptions, link.hash));\n    };\n}\n\nfunction isInvalid(link: Element): boolean {\n    return [\n        isNotAnchor,\n        isExternalLink,\n        isNotAnchorOnSamePage,\n        isAnchorEmpty,\n    ].some((f) => f(link));\n}\n\nfunction isNonAjaxcomCall(event: MouseEvent) {\n    return event.which > 1 || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey;\n}\n\nfunction isNotAnchor(link: Element) {\n    return link.tagName.toUpperCase() !== \"A\";\n}\n\nfunction isExternalLink(link: HTMLAnchorElement) {\n    return link.hostname !== location.hostname || link.protocol !== location.protocol;\n}\n\nfunction isNotAnchorOnSamePage(link: HTMLAnchorElement) {\n    return link.hash && link.href.replace(link.hash, \"\") === location.href.replace(location.hash, \"\");\n}\n\nfunction isAnchorEmpty(link: HTMLAnchorElement) {\n    return link.href === location.href + \"#\";\n}\n\nfunction getLink(event: MouseEvent) {\n    const link = (event.target || event.srcElement) as HTMLAnchorElement;\n\n    if (isNotAnchor(link)) {\n        return link.parentElement as HTMLAnchorElement;\n    }\n\n    return link;\n}\n","import {handleCallback} from \"../operation/callback\";\nimport {handleChangeUrl} from \"../operation/changeUrl\";\nimport {handleContainer} from \"../operation/container\";\nimport {IOperationOptions} from \"../operation/options/operationOptions\";\nimport {IAjaxcomCallbacks} from \"../options/callbacks\";\nimport {IFetchOptions} from \"../options/fetchOptions\";\n\nexport function fetchOperations(options: Partial<IAjaxcomCallbacks & IFetchOptions>): Promise<Response> {\n    return fetch(options.url, {\n        body: options.body,\n        cache: \"no-store\",\n        credentials: \"include\",\n        headers: new Headers({...options.headers, \"X-AjaxCom\": \"true\", \"Accept\": \"application/json\"}),\n        method: options.method,\n    });\n}\n\nexport function handleOperations(response: Response): Promise<any> {\n    return response\n        .json()\n        .then((data: IOperationOptions[]) => {\n            data.forEach((operation) => handleOperation(operation));\n        });\n}\n\nfunction handleOperation({operation, options}: IOperationOptions) {\n    switch (operation) {\n        case \"container\":\n            handleContainer(options);\n            break;\n        case \"changeurl\":\n            handleChangeUrl(options);\n            break;\n        case \"callback\":\n            handleCallback(options);\n            break;\n        default:\n            throw new Error(\"Operation \" + operation + \" is not supported\");\n    }\n}\n","import {ICallbackOptions} from \"./options/callbackOptions\";\n\nexport function handleCallback(options: ICallbackOptions) {\n    const namespaces = options.callFunction.split(\".\");\n    let context: any = window;\n\n    namespaces.forEach((item) => {\n        if (context[item] === undefined) {\n            throw new Error('Invalid callback \"' + options.callFunction + '\"');\n        }\n        context = context[item];\n    });\n\n    if (typeof context === \"function\") {\n        context(options.params);\n    }\n}\n","import {IChangeUrlOptions} from \"./options/changeUrlOptions\";\n\nexport function handleChangeUrl(options: IChangeUrlOptions) {\n    let handler;\n\n    switch (options.method) {\n        case \"push\":\n            handler = pushUrl(options);\n            break;\n        case \"replace\":\n            handler = replaceUrl(options);\n            break;\n        case \"redirect\":\n            handler = redirectToUrl(options);\n            break;\n        default:\n            throw new Error(\"ChangeUrl method \" + options.method + \" is not supported\");\n    }\n\n    setTimeout(handler, options.wait);\n}\n\nfunction pushUrl(options: IChangeUrlOptions) {\n    const currentUrlHref = window.location.href + window.location.search;\n    const currentUrlPath = window.location.pathname + window.location.search;\n\n    if (currentUrlHref === options.url || currentUrlPath === options.url) { return; }\n\n    history.pushState(options, null, options.url);\n}\n\nfunction replaceUrl(options: IChangeUrlOptions) {\n    history.replaceState(options, null, options.url);\n}\n\nfunction redirectToUrl(options: IChangeUrlOptions) {\n    window.location.href = options.url;\n}\n","import {IContainerOptions} from \"./options/containerOptions\";\n\nexport function handleContainer(options: IContainerOptions) {\n    const selection = document.querySelectorAll(options.target);\n\n    // if elements are not present in DOM just ignore the handler\n    if (selection === null) {\n        return;\n    }\n\n    const elements = Array.from(selection) as Element[];\n\n    function html() {\n        elements.forEach((element) => {\n            element.innerHTML = options.value;\n        });\n    }\n\n    function remove() {\n        elements.forEach((element) => {\n            element.remove();\n        });\n    }\n\n    function append() {\n        const nodes = getNodes(options.value);\n        elements.forEach((element) => {\n            element.appendChild(nodes);\n        });\n    }\n\n    function prepend() {\n        const nodes = getNodes(options.value);\n        elements.forEach((element) => {\n            element.insertBefore(nodes, element.firstChild);\n        });\n    }\n\n    function insertBefore() {\n        const nodes = getNodes(options.value);\n        elements.forEach((element) => {\n            element.parentNode.insertBefore(nodes, element);\n        });\n    }\n\n    function insertAfter() {\n        const nodes = getNodes(options.value);\n        elements.forEach((element) => {\n            element.parentNode.insertBefore(nodes, element.nextSibling);\n        });\n    }\n\n    function replace() {\n        elements.forEach((element) => {\n            element.outerHTML = options.value;\n        });\n    }\n\n    function addClass() {\n        elements.forEach((element) => {\n            element.classList.add(options.value);\n        });\n    }\n\n    function removeClass() {\n        elements.forEach((element) => {\n            element.classList.remove(options.value);\n        });\n    }\n\n    function attr() {\n        elements.forEach((element) => {\n            element.setAttribute(options.attr, options.value);\n        });\n    }\n\n    switch (options.method) {\n        case \"html\":\n            html();\n            break;\n        case \"remove\":\n            remove();\n            break;\n        case \"append\":\n            append();\n            break;\n        case \"prepend\":\n            prepend();\n            break;\n        case \"insertBefore\":\n            insertBefore();\n            break;\n        case \"insertAfter\":\n            insertAfter();\n            break;\n        case \"replace\":\n            replace();\n            break;\n        case \"addClass\":\n            addClass();\n            break;\n        case \"removeClass\":\n            removeClass();\n            break;\n        case \"attr\":\n            attr();\n            break;\n        default:\n            throw new Error(\"Container method \" + options.method + \" is not supported\");\n    }\n}\n\nfunction getNodes(html: string) {\n    return document.createRange().createContextualFragment(html);\n}\n","import {IAjaxcomCallbacks} from \"../options/callbacks\";\nimport {IFetchOptions} from \"../options/fetchOptions\";\nimport {IAjaxcomSelectors} from \"../options/selectors\";\nimport {addFragmentOptions} from \"./fragmentOptions\";\nimport {request} from \"./request\";\n\nexport function toHandleSubmit(options?: Partial<IAjaxcomSelectors & IAjaxcomCallbacks>) {\n    return (event: Event) => {\n        const form = event.target as HTMLFormElement;\n\n        if (false === form.matches(options.formsSelector)) { return; }\n        if (form.tagName.toUpperCase() !== \"FORM\") { return; }\n        event.preventDefault();\n\n        const formData = new FormData(form);\n        const fetchOptions = {\n            ...options,\n            method: form.method,\n            url: form.action ? form.action : window.location.href,\n        };\n\n        request(getFetchOptions(form, formData, fetchOptions));\n    };\n}\n\nfunction getFetchOptions(form: HTMLFormElement, formData: FormData, fetchOptions: SubmitOptions): SubmitOptions {\n    const options = form.method.toUpperCase() === \"GET\"\n        ? fetchOptionsForGet(formData, fetchOptions)\n        : fetchOptionsForPost(formData, fetchOptions);\n\n    const hashPosition = form.action.indexOf(\"#\");\n\n    if (hashPosition < 0) { return options; }\n\n    const fragment = form.action.substring(hashPosition);\n\n    return addFragmentOptions(options, fragment);\n}\n\ntype SubmitOptions = Partial<IAjaxcomCallbacks & IFetchOptions>;\n\nfunction fetchOptionsForPost(formData: FormData, fetchOptions: SubmitOptions): SubmitOptions {\n    return {\n        ...fetchOptions,\n        body: formData,\n    };\n}\n\nfunction fetchOptionsForGet(formData: any, fetchOptions: SubmitOptions): SubmitOptions {\n    const query = [...formData.entries()].map((pair) => `${encodeURIComponent(pair[0])}=${pair[1]}`).join(\"&\");\n    const glue = fetchOptions.url.indexOf(\"?\") === -1 ? \"?\" : \"&\";\n\n    return {\n        ...fetchOptions,\n        url: [fetchOptions.url, glue, query].join(\"\"),\n    };\n}\n"],"sourceRoot":""}